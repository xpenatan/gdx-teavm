// Custom Glue
//
//interface MybtTriangleRaycastCallback {
//    void MybtTriangleRaycastCallback([Const, Ref]btVector3 from, [Const, Ref]btVector3 to, optional long flags);
//    float reportHit([Const, Ref]btVector3 hitNormalLocal, float hitFraction, long partId, long triangleIndex);
//};
//MybtTriangleRaycastCallback implements btTriangleRaycastCallback;
//
//interface MyMotionState {
//    void MyMotionState();
//};
//MyMotionState implements btMotionState;
//
interface Bullet {
    long getBTVersion();
////  void setVertices(btIndexedMesh mesh, float [] vertices, long sizeInBytesOfEachVertex, long vertexCount, long positionOffsetInBytes);
////  void setIndices(btIndexedMesh mesh, short [] indices, long indexOffset, long indexCount);
//    [Const, Ref]btVector3 getVertexPointer(btShapeHull hull, long index);
};

//interface MyTemp {
//    [Value]btVector3 btVec3_1(float x, float y, float z);
//    [Value]btVector3 btVec3_2(float x, float y, float z);
//    [Value]btQuaternion btQuat();
//    [Value]btTransform btTran();
//    [Value]btMatrix3x3 btMat3();
//};
//
//interface MyCollisionObjectArray {
//    void MyCollisionObjectArray();
//    [Const] long size();
//    [Const] btCollisionObject at(long n);
//    void resize(long value);
//    long capacity();
//};
//
//interface MyVector3Array {
//    void MyVector3Array();
//    [Const] long size();
//    [Value] btVector3 at(long n);
//    void resize(long value);
//    long capacity();
//};
//
//interface MyScalarArray {
//    void MyScalarArray();
//    [Const] long size();
//    float at(long n);
//    void resize(long value);
//    long capacity();
//};
//
//interface MyClosestRayResultCallback {
//    void MyClosestRayResultCallback([Const, Ref] btVector3 from, [Const, Ref] btVector3 to);
//    float addSingleResult([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
//    float addSingleResultSuper([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
//};
//MyClosestRayResultCallback implements ClosestRayResultCallback;
//
//interface MyAllHitsRayResultCallback {
//    void MyAllHitsRayResultCallback([Const, Ref] btVector3 from, [Const, Ref] btVector3 to);
//    float addSingleResult([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
//    float addSingleResultSuper([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
//};
//MyAllHitsRayResultCallback implements AllHitsRayResultCallback;
//
//
//interface MyRayResultCallback {
//    void MyRayResultCallback();
//    float addSingleResult([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
//};
//MyRayResultCallback implements RayResultCallback;
//
//// Custom Class
[Prefix = "btCollisionWorld::"]
interface ContactResultCallback {
    float addSingleResult([Ref]btManifoldPoint cp, [Const]btCollisionObjectWrapper colObj0Wrap, long partId0, long index0, [Const]btCollisionObjectWrapper colObj1Wrap, long partId1, long index1);
    boolean needsCollision(btBroadphaseProxy proxy0);
};

[NoDelete]
interface btCollisionObjectWrapper {
};

//[JSImplementation="ContactResultCallback"]
//interface ConcreteContactResultCallback {
//    void ConcreteContactResultCallback();
//    float addSingleResult([Ref] btManifoldPoint cp, [Const] btCollisionObjectWrapper colObj0Wrap, long partId0, long index0, [Const] btCollisionObjectWrapper colObj1Wrap, long partId1, long index1);
//};
//
//// Linear Math
//
interface btVector3 {
    void btVector3();
    void btVector3(float x, float y, float z);
    float length();
    float getX();
    float getY();
    float getZ();
    void setX(float x);
    void setY(float y);
    void setZ(float z);
    void setValue(float x, float y, float z);
};

interface btQuadWord {
    float getX();
    float getY();
    float getZ();
    void setX(float x);
    void setY(float y);
    void setZ(float z);
    void setW(float w);
};

interface btQuaternion {
    void btQuaternion();
    void btQuaternion(float x, float y, float z, float w);
    void setValue(float x, float y, float z, float w);
    void setEulerZYX(float z, float y, float x);
    void setRotation([Const, Ref] btVector3 axis, float angle);
    float getW();
    void normalize();
};
btQuaternion implements btQuadWord;

interface btMatrix3x3 {
    void btMatrix3x3();
    void setEulerZYX(float ex, float ey, float ez);
    void getRotation([Ref]btQuaternion q);
    [Operator="[]", Ref] btVector3 getRow(long i);
    [Value]btVector3 getColumn(long y);

};

interface btTransform {
    void btTransform();
    void btTransform([Ref]btQuaternion q, [Ref]btVector3 v);
    void setIdentity();
    void setOrigin([Ref]btVector3 origin);
    void setRotation([Ref]btQuaternion rotation);
    [Ref]btVector3 getOrigin();
    [Value]btQuaternion getRotation();
    [Ref]btMatrix3x3 getBasis();
    void setFromOpenGLMatrix(float[] m);
    void getOpenGLMatrix(float[] m);
};

interface btMotionState {
    [Const] void getWorldTransform([Ref]btTransform worldTrans);
    void setWorldTransform([Const, Ref]btTransform worldTrans);
};

[JSImplementation="btMotionState"]
interface MotionStateImpl {
    void MotionStateImpl();
    [Const] void getWorldTransform([Ref]btTransform worldTrans);
    void setWorldTransform([Const, Ref]btTransform worldTrans);
};

interface btIDebugDraw {};

//[JSImplementation="btIDebugDraw"]
//interface DebugDrawImpl {
//    void DebugDrawImpl();
//    void drawLine([Const, Ref] btVector3 vecFrom, [Const, Ref] btVector3 vecTo, [Const, Ref] btVector3 color);
//    void drawContactPoint([Const, Ref] btVector3 PointOnB, [Const, Ref] btVector3 normalOnB, float distance, long lifeTime, [Const, Ref] btVector3 color);
////  void draw3dText([Const, Ref] btVector3 loc, [Const] DOMString textString);
//    long getDebugMode();
//};

// Collision

interface btCollisionWorld {
    void btCollisionWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btCollisionConfiguration collisionConfiguration);
//    void setBroadphase(btBroadphaseInterface pairCache);
//    //btBroadphaseInterface getBroadphase(); //Not needed
//    //btOverlappingPairCache getPairCache(); //Not needed
//    btDispatcher getDispatcher();
//    void updateSingleAabb(btCollisionObject colObj);
//    void updateAabbs();
//    void computeOverlappingPairs();
//    void setDebugDrawer(btIDebugDraw debugDrawer);
//    //btIDebugDraw getDebugDrawer(); //Not needed
//    void debugDrawWorld();
//    void debugDrawObject ([Const, Ref] btTransform worldTransform, [Const] btCollisionShape shape, [Const, Ref] btVector3 color);
//    long getNumCollisionObjects();
//    void rayTest([Const, Ref]btVector3 rayFromWorld, [Const, Ref]btVector3 rayToWorld, [Ref]RayResultCallback resultCallback);
//    void convexSweepTest([Const]btConvexShape castShape, [Const, Ref]btTransform from, [Const, Ref]btTransform to, [Ref]ConvexResultCallback resultCallback, optional float allowedCcdPenetration);
//    void contactTest(btCollisionObject colObj, [Ref]ContactResultCallback resultCallback);
//    void contactPairTest(btCollisionObject colObjA, btCollisionObject colObjB, [Ref]ContactResultCallback resultCallback);
//    void addCollisionObject(btCollisionObject collisionObject, optional long collisionFilterGroup, optional long collisionFilterMask);
//    [Ref]btCollisionObjectArray getCollisionObjectArray();
//    void removeCollisionObject(btCollisionObject collisionObject);
//    void performDiscreteCollisionDetection();
//    [Ref]btDispatcherInfo getDispatchInfo();
//    boolean getForceUpdateAllAabbs ();
//    void setForceUpdateAllAabbs(boolean f);
};

interface btCollisionConfiguration {};

interface btDefaultCollisionConstructionInfo {
    void btDefaultCollisionConstructionInfo();
};

interface btDefaultCollisionConfiguration {
    void btDefaultCollisionConfiguration([Ref]optional btDefaultCollisionConstructionInfo info);
};
btDefaultCollisionConfiguration implements btCollisionConfiguration;

interface btCollisionObject {
    void btCollisionObject();
    boolean mergesSimulationIslands();
    [Const, Ref] btVector3 getAnisotropicFriction();
    void setAnisotropicFriction([Const, Ref]btVector3 anisotropicFriction, long frictionMode);
    boolean hasAnisotropicFriction(optional long frictionMode);
    void setContactProcessingThreshold(float contactProcessingThreshold);
    float getContactProcessingThreshold();
    boolean isStaticObject();
    boolean isKinematicObject();
    boolean isStaticOrKinematicObject();
    boolean hasContactResponse();
    void setCollisionShape(btCollisionShape collisionShape);
    //btCollisionShape getCollisionShape(); //Not needed
    void setIgnoreCollisionCheck([Const] btCollisionObject obj, boolean ignoreCollisionCheck);
    boolean checkCollideWithOverride([Const] btCollisionObject obj);
    long getActivationState();
    void setActivationState(long newState);
    void setDeactivationTime(float time);
    float getDeactivationTime();
    void forceActivationState(long newState);
    void activate(optional boolean forceActivation);
    boolean isActive();
    void setRestitution(float rest);
    float getRestitution();
    void setFriction(float frict);
    float getFriction();
    void setRollingFriction(float frict);
    float getRollingFriction();
    [Ref]btTransform getWorldTransform();
    void setWorldTransform([Const, Ref]btTransform worldTrans);
    btBroadphaseProxy getBroadphaseHandle();
    void setBroadphaseHandle(btBroadphaseProxy handle);
    [Ref] btTransform getInterpolationWorldTransform();
    void setInterpolationWorldTransform([Const, Ref]btTransform trans);
    void setInterpolationLinearVelocity([Const, Ref]btVector3 linvel);
    void setInterpolationAngularVelocity([Const, Ref]btVector3 angvel);
    [Const, Ref]btVector3 getInterpolationLinearVelocity();
    [Const, Ref]btVector3 getInterpolationAngularVelocity();
    long getIslandTag();
    void setIslandTag(long tag);
    long getCompanionId();
    void setCompanionId(long id);
    float getHitFraction();
    void setHitFraction(float hitFraction);
    long getCollisionFlags();
    void setCollisionFlags(long flags);
    float getCcdSweptSphereRadius();
    void setCcdSweptSphereRadius(float radius);
    float getCcdMotionThreshold();
    float getCcdSquareMotionThreshold();
    void setCcdMotionThreshold(float ccdMotionThreshold);
    any getUserPointer();
    long getUserIndex();
    void setUserPointer(any userPointer);
    void setUserIndex(long index);
    long getUpdateRevisionInternal();
    boolean checkCollideWith([Const] btCollisionObject co);
};

interface btManifoldPoint {
    [Const, Ref]btVector3 getPositionWorldOnA();
    [Const, Ref]btVector3 getPositionWorldOnB();
    float getAppliedImpulse();
    float getDistance();
    [Value]attribute btVector3 m_localPointA;
    [Value]attribute btVector3 m_localPointB;
    [Value]attribute btVector3 m_positionWorldOnB;
    [Value]attribute btVector3 m_positionWorldOnA;
    [Value]attribute btVector3 m_normalWorldOnB;
    long getLifeTime();
};

interface btBroadphaseProxy {};

//[Prefix = "btCollisionWorld::"]
//interface LocalRayResult {
//    [Const]attribute btCollisionObject m_collisionObject;
//    attribute LocalShapeInfo m_localShapeInfo;
//    [Value]attribute btVector3 m_hitNormalLocal;
//    attribute float m_hitFraction;
//};
//
//[Prefix = "btCollisionWorld::"]
//interface RayResultCallback {
//    // abstract base class, no constructor
//    boolean hasHit();
//    attribute float m_closestHitFraction;
//    attribute long m_collisionFilterGroup;
//    attribute long m_collisionFilterMask;
//    [Const]attribute btCollisionObject m_collisionObject;
//    attribute unsigned long m_flags;
//    float addSingleResult([Ref]LocalRayResult rayResult, boolean normalInWorldSpace);
//};
//
//[Prefix = "btCollisionWorld::"]
//interface ClosestRayResultCallback {
//    void ClosestRayResultCallback([Const, Ref]btVector3 from, [Const, Ref]btVector3 to);
//    [Value]attribute btVector3 m_rayFromWorld;
//    [Value]attribute btVector3 m_rayToWorld;
//    [Value]attribute btVector3 m_hitNormalWorld;
//    [Value]attribute btVector3 m_hitPointWorld;
//};
//ClosestRayResultCallback implements RayResultCallback;
//
//[Prefix = "btCollisionWorld::"]
//interface AllHitsRayResultCallback {
//    void AllHitsRayResultCallback([Const, Ref]btVector3 from, [Const, Ref]btVector3 to);
//    [Value]attribute MyCollisionObjectArray m_collisionObjects;
//    [Value]attribute btVector3 m_rayFromWorld;
//    [Value]attribute btVector3 m_rayToWorld;
//    [Value]attribute MyVector3Array m_hitNormalWorld;
//    [Value]attribute MyVector3Array m_hitPointWorld;
//    [Value]attribute MyScalarArray m_hitFractions;
//};
//AllHitsRayResultCallback implements RayResultCallback;
//
//[Prefix = "btCollisionWorld::"]
//interface LocalShapeInfo {
//    attribute long m_shapePart;
//    attribute long m_triangleIndex;
//};
//
//[Prefix = "btCollisionWorld::"]
//interface LocalConvexResult {
//    void LocalConvexResult([Const]btCollisionObject hitCollisionObject, LocalShapeInfo localShapeInfo, [Const, Ref]btVector3 hitNormalLocal, [Const, Ref]btVector3 hitPointLocal, float hitFraction);
//    [Const]attribute btCollisionObject m_hitCollisionObject;
//    attribute LocalShapeInfo m_localShapeInfo;
//    [Value]attribute btVector3 m_hitNormalLocal;
//    [Value]attribute btVector3 m_hitPointLocal;
//    attribute float m_hitFraction;
//};
//
//[Prefix = "btCollisionWorld::"]
//interface ConvexResultCallback {
//    // abstract base class, no constructor
//    boolean hasHit();
//    attribute long m_collisionFilterGroup;
//    attribute long m_collisionFilterMask;
//    attribute float m_closestHitFraction;
//};
//
//[Prefix = "btCollisionWorld::"]
//interface ClosestConvexResultCallback {
//    void ClosestConvexResultCallback([Const, Ref]btVector3 convexFromWorld, [Const, Ref]btVector3 convexToWorld);
//    [Value]attribute btVector3 m_convexFromWorld;
//    [Value]attribute btVector3 m_convexToWorld;
//    [Value]attribute btVector3 m_hitNormalWorld;
//    [Value]attribute btVector3 m_hitPointWorld;
//};
//ClosestConvexResultCallback implements ConvexResultCallback;

interface btPersistentManifold {
    void btPersistentManifold();
    [Const]btCollisionObject getBody0();
    [Const]btCollisionObject getBody1();
    long getNumContacts();
    [Ref]btManifoldPoint getContactPoint(long index);
};

interface btDispatcher {
    long getNumManifolds();
    btPersistentManifold getManifoldByIndexInternal(long index);
};

interface btCollisionDispatcher {
    void btCollisionDispatcher(btCollisionConfiguration conf);
};
btCollisionDispatcher implements btDispatcher;

interface btOverlappingPairCallback {};

interface btCollisionAlgorithm {
    void getAllContactManifolds([Ref]btManifoldArray manifoldArray);
};

//interface btGearConstraint {
//    void btGearConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btVector3 axisInA, [Const, Ref]btVector3 axisInB, optional float ratio);
//};

interface btBroadphasePair {
    attribute btCollisionAlgorithm m_algorithm;
};

interface btOverlappingPairCache {
    void setInternalGhostPairCallback(btOverlappingPairCallback ghostPairCallback);
    [Ref]btBroadphasePairArray getOverlappingPairArray();
};

//interface btAxisSweep3 {
//    void btAxisSweep3([Ref]btVector3 worldAabbMin, [Ref]btVector3 worldAabbMax, optional long maxHandles, optional btOverlappingPairCache pairCache, optional boolean disableRaycastAccelerator);
//};
//btAxisSweep3 implements btBroadphaseInterface;

interface btBroadphaseInterface {
    btOverlappingPairCache getOverlappingPairCache();
};

interface btDbvtBroadphase {
    void btDbvtBroadphase();
};
btDbvtBroadphase implements btBroadphaseInterface;

// Arrays

interface btManifoldArray {
    void btManifoldArray();
    [Const]long size();
    [Const]btPersistentManifold at(long n);
    void resize(long value);
    long capacity();
};

interface btBroadphasePairArray {
    [Const]long size();
    [Const, Ref]btBroadphasePair at(long n);
    void resize(long value);
    long capacity();
};

//interface btCollisionObjectArray {
//    [Const]long size();
//    [Const]btCollisionObject at(long n);
//    void resize(long value);
//    long capacity();
//};
//
//interface btStridingMeshInterface {};

// Shapes

interface btCollisionShape {
    void setLocalScaling([Const, Ref]btVector3 scaling);
    void calculateLocalInertia(float mass, [Ref]btVector3 inertia);
    void setMargin(float margin);
    float getMargin();
    long getShapeType();
    void getAabb([Const, Ref]btTransform t, [Ref]btVector3 aabbMin, [Ref]btVector3 aabbMax);
};

interface btConvexShape {
    long getNumPreferredPenetrationDirections();
    void getPreferredPenetrationDirection(long index, [Ref]btVector3 penetrationVector);
};
btConvexShape implements btCollisionShape;

interface btConvexInternalShape {
    void setImplicitShapeDimensions([Ref]btVector3 dimensions);
};
btConvexInternalShape implements btConvexShape;

interface btPolyhedralConvexShape {
};
btPolyhedralConvexShape implements btConvexInternalShape;
//
//interface btPolyhedralConvexAabbCachingShape {
//};
//btPolyhedralConvexAabbCachingShape implements btPolyhedralConvexShape;
//
//interface btConvexTriangleMeshShape {
//    void btConvexTriangleMeshShape(btStridingMeshInterface meshInterface, optional boolean calcAabb);
//};
//btConvexTriangleMeshShape implements btPolyhedralConvexAabbCachingShape;

interface btBoxShape {
    void btBoxShape([Ref]btVector3 boxHalfExtents);
    void setMargin(float margin);
    [Ref,Const] btVector3 getHalfExtentsWithoutMargin();
    float getMargin();
};
btBoxShape implements btPolyhedralConvexShape;
//
//interface btCapsuleShape {
//    void btCapsuleShape(float radius, float height);
//    void setMargin(float margin);
//    float getMargin();
//};
//btCapsuleShape implements btConvexInternalShape;
//
//interface btCapsuleShapeX {
//    void btCapsuleShapeX(float radius, float height);
//    void setMargin(float margin);
//    float getMargin();
//};
//btCapsuleShapeX implements btCapsuleShape;
//
//interface btCapsuleShapeZ {
//    void btCapsuleShapeZ(float radius, float height);
//    void setMargin(float margin);
//    float getMargin();
//};
//btCapsuleShapeZ implements btCapsuleShape;
//
//interface btCylinderShape {
//    void btCylinderShape([Ref]btVector3 halfExtents);
//    void setMargin(float margin);
//    float getMargin();
//};
//btCylinderShape implements btConvexInternalShape;
//
//interface btCylinderShapeX {
//    void btCylinderShapeX([Ref]btVector3 halfExtents);
//    void setMargin(float margin);
//    float getMargin();
//};
//btCylinderShapeX implements btCylinderShape;
//
//interface btCylinderShapeZ {
//    void btCylinderShapeZ([Ref]btVector3 halfExtents);
//    void setMargin(float margin);
//    float getMargin();
//};
//btCylinderShapeZ implements btCylinderShape;
//
//interface btSphereShape {
//    void btSphereShape(float radius);
//    float getRadius();
//    void setUnscaledRadius(float radius);
//    void setMargin(float margin);
//    float getMargin();
//};
//btSphereShape implements btConvexInternalShape;
//
//interface btConeShape {
//    void btConeShape(float radius, float height);
//};
//btConeShape implements btConvexInternalShape;
//
////interface btConvexHullShape {
////    void btConvexHullShape([Const] optional float[] points, optional long numPoints, optional long stride);
////    void addPoint([Const, Ref]btVector3 point, optional boolean recalculateLocalAABB);
////    void setMargin(float margin);
////    float getMargin();
////    long getNumPoints();
////    [Value]btVector3 getScaledPoint(long i);
////    void optimizeConvexHull();
////};
////btConvexHullShape implements btPolyhedralConvexAabbCachingShape;
//
//interface btConeShapeX {
//    void btConeShapeX(float radius, float height);
//};
//btConeShapeX implements btConeShape;
//
//interface btConeShapeZ {
//    void btConeShapeZ(float radius, float height);
//};
//btConeShapeZ implements btConeShape;
//
//interface btCompoundShape {
//    void btCompoundShape(optional boolean enableDynamicAabbTree);
//    void addChildShape([Const, Ref]btTransform localTransform, btCollisionShape shape);
//    void removeChildShapeByIndex(long childShapeindex);
//    void removeChildShape(btCollisionShape shape);
//    [Const]long getNumChildShapes();
//    btCollisionShape getChildShape(long index);
//    void setMargin(float margin);
//    float getMargin();
//    void recalculateLocalAabb();
//};
//btCompoundShape implements btCollisionShape;
//
//interface btConcaveShape {};
//btConcaveShape implements btCollisionShape;
//
//interface btStaticPlaneShape {
//    void btStaticPlaneShape([Const, Ref]btVector3 planeNormal, float planeConstant);
//};
//btStaticPlaneShape implements btConcaveShape;
//
//interface btTriangleMeshShape {};
//btTriangleMeshShape implements btConcaveShape;
//
//interface btBvhTriangleMeshShape {
//    void btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, optional boolean buildBvh);
//    void btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, [Const, Ref]btVector3 bvhAabbMin, [Const, Ref]btVector3 bvhAabbMax, optional boolean buildBvh);
//    void performRaycast(btTriangleCallback callback, [Const, Ref]btVector3 raySource, [Const, Ref]btVector3 rayTarget);
//};
//btBvhTriangleMeshShape implements btTriangleMeshShape;
//
////interface btHeightfieldTerrainShape {
////    void btHeightfieldTerrainShape(long heightStickWidth, long heightStickLength, VoidPtr heightfieldData, float heightScale, float minHeight, float maxHeight, long upAxis, PHY_ScalarType hdt, boolean flipQuadEdges);
////    void setMargin(float margin);
////    float getMargin();
////};
////btHeightfieldTerrainShape implements btConcaveShape;
//
//interface btScaledBvhTriangleMeshShape {
//    void btScaledBvhTriangleMeshShape(btBvhTriangleMeshShape childShape, [Const, Ref]btVector3 localScaling);
//};
//
//interface btShapeHull {
//    void btShapeHull(btConvexShape shape);
//    long numTriangles();
//    long numVertices();
//    long numIndices();
//    boolean buildHull(float margin);
//};
//
//// Other stuff
//
//enum PHY_ScalarType {
//    "PHY_FLOAT",
//    "PHY_DOUBLE",
//    "PHY_INTEGER",
//    "PHY_SHORT",
//    "PHY_FIXEDPOINT88",
//    "PHY_UCHAR"
//};
//
//interface btIndexedMesh {
//    void btIndexedMesh();
//};
//
//interface btTriangleMesh {
//    void btTriangleMesh(optional boolean use32bitIndices, optional boolean use4componentVertices);
//    void addTriangle([Const, Ref]btVector3 vertex0, [Const, Ref]btVector3 vertex1, [Const, Ref]btVector3 vertex2, optional boolean removeDuplicateVertices);
//    void findOrAddVertex([Const, Ref]btVector3 vertex, boolean removeDuplicateVertices);
//    void addIndex(long index);
//};
//btTriangleMesh implements btStridingMeshInterface;
//
//interface btTriangleIndexVertexArray {
//    void btTriangleIndexVertexArray();
//    void setPremadeAabb([Const, Ref]btVector3 aabbMin, [Const, Ref]btVector3 aabbMax);
//    void getPremadeAabb(btVector3 aabbMin, btVector3 aabbMax);
//    boolean hasPremadeAabb();
////    void addIndexedMesh([Const, Ref]btIndexedMesh mesh, optional PHY_ScalarType indexType);
//};
//btTriangleIndexVertexArray implements btStridingMeshInterface;
//
//interface btTriangleRaycastCallback {
//    [Value]attribute btVector3 m_from;
//    [Value]attribute btVector3 m_to;
//    attribute float m_hitFraction;
//    attribute unsigned long m_flags;
//    float reportHit([Const, Ref]btVector3 hitNormalLocal, float hitFraction, long partId, long triangleIndex);
//};
//btTriangleRaycastCallback implements btTriangleCallback;
//
//interface btTriangleCallback {
//    void processTriangle(btVector3 triangle, long partId, long triangleIndex);
//};
//
// Dynamics

[Prefix = "btRigidBody::"]
interface btRigidBodyConstructionInfo {
    void btRigidBodyConstructionInfo(float mass, btMotionState motionState, btCollisionShape collisionShape, [Ref]optional btVector3 localInertia);
    attribute float m_linearDamping;
    attribute float m_angularDamping;
    attribute float m_friction;
    attribute float m_rollingFriction;
    attribute float m_restitution;
    attribute float m_linearSleepingThreshold;
    attribute float m_angularSleepingThreshold;
    attribute boolean m_additionalDamping;
    attribute float m_additionalDampingFactor;
    attribute float m_additionalLinearDampingThresholdSqr;
    attribute float m_additionalAngularDampingThresholdSqr;
    attribute float m_additionalAngularDampingFactor;
};

interface btRigidBody {
    void btRigidBody([Const, Ref]btRigidBodyConstructionInfo constructionInfo);
    void btRigidBody (float mass, btMotionState motionState, btCollisionShape collisionShape, [Const, Ref] optional btVector3 localInertia);
//    attribute long m_contactSolverType;
//    attribute long m_frictionSolverType;
//    void proceedToTransform([Const, Ref]btTransform newTrans);
//    void predictIntegratedTransform(float step, [Ref]btTransform predictedTransform);
//    void saveKinematicState(float step);
//    void applyGravity();
//    void setGravity([Const, Ref]btVector3 acceleration);
//    [Const, Ref]btVector3 getGravity();
//    void setDamping(float lin_damping, float ang_damping);
//    float getLinearDamping();
//    float getAngularDamping();
//    float getLinearSleepingThreshold();
//    float getAngularSleepingThreshold();
//    void applyDamping(float timeStep);
//    void setMassProps(float mass, [Const, Ref]btVector3 inertia);
//    [Const, Ref]btVector3 getLinearFactor();
//    void setLinearFactor([Const, Ref]btVector3 linearFactor);
//    float getInvMass();
//    [Const,Ref]btMatrix3x3 getInvInertiaTensorWorld();
//    void integrateVelocities(float step);
//    void setCenterOfMassTransform([Const, Ref]btTransform xform);
//    void applyCentralForce([Const, Ref]btVector3 force);
//    [Const, Ref]btVector3 getTotalForce();
//    [Const, Ref]btVector3 getTotalTorque();
//    [Const, Ref]btVector3 getInvInertiaDiagLocal();
//    void setInvInertiaDiagLocal([Const,Ref]btVector3 diagInvInertia);
//    void setSleepingThresholds(float linear, float angular);
//    void applyTorque([Const, Ref]btVector3 torque);
//    void applyForce([Const, Ref]btVector3 force, [Const, Ref]btVector3 rel_pos);
//    void applyCentralImpulse([Const, Ref]btVector3 impulse);
//    void applyTorqueImpulse([Const, Ref]btVector3 torque);
//    void applyImpulse([Const, Ref]btVector3 impulse, [Const, Ref]btVector3 rel_pos);
//    void clearForces();
//    void updateInertiaTensor();
//    [Const, Ref]btVector3 getCenterOfMassPosition();
//    [Const, Ref]btTransform getCenterOfMassTransform();
//    [Const, Ref]btVector3 getLinearVelocity();
//    [Const, Ref]btVector3 getAngularVelocity();
//    void setLinearVelocity([Const, Ref]btVector3 lin_vel);
//    void setAngularVelocity([Const, Ref]btVector3 ang_vel);
//    void translate([Const, Ref]btVector3 trs);
//    void getAabb([Ref]btVector3 aabbMin, [Ref]btVector3 aabbMax);
//    float computeImpulseDenominator([Const, Ref]btVector3 pos, [Const, Ref]btVector3 normal);
//    float computeAngularImpulseDenominator([Const, Ref]btVector3 axis);
//    void updateDeactivation(float timeStep);
//    boolean wantsSleeping();
//    //btBroadphaseProxy getBroadphaseProxy(); // Not needed. btCollisionObject already have this call
//    //void setNewBroadphaseProxy(btBroadphaseProxy broadphaseProxy) // Not needed
//    btMotionState getMotionState();
//    void setMotionState(btMotionState motionState);
//    void setAngularFactor([Const, Ref]btVector3 angFac);
//    [Const, Ref]btVector3 getAngularFactor();
//    boolean isInWorld();
//    void addConstraintRef(btTypedConstraint c);
//    void removeConstraintRef(btTypedConstraint c);
//    btTypedConstraint getConstraintRef(long index);
//    long getNumConstraintRefs();
//    void setFlags(long flags);
//    long getFlags();
//    [Value]btQuaternion getOrientation();
//    [Value]btVector3 getVelocityInLocalPoint([Const, Ref]btVector3 rel_pos);
//    [Value]btVector3 computeGyroscopicImpulseImplicit_World(float dt);
//    [Value]btVector3 computeGyroscopicImpulseImplicit_Body(float step);
//    [Value]btVector3 computeGyroscopicForceExplicit(float maxGyroscopicForce);
//    [Value]btVector3 getLocalInertia();
};
btRigidBody implements btCollisionObject;
//
//interface btConstraintSetting {
//    void btConstraintSetting();
//    attribute float m_tau;
//    attribute float m_damping;
//    attribute float m_impulseClamp;
//};

interface btTypedConstraint {
    void enableFeedback(boolean needsFeedback);
    [Const]float getBreakingImpulseThreshold();
    void setBreakingImpulseThreshold([Const]float threshold);
    [Const, Ref]btRigidBody getRigidBodyA();
    [Const, Ref]btRigidBody getRigidBodyB();
};

//interface btGeneric6DofSpring2Constraint {
//    void btGeneric6DofSpring2Constraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btTransform frameInA, [Const, Ref]btTransform frameInB);
//    void setDbgDrawSize(float dbgDrawSize);
//    void setLinearLowerLimit([Const, Ref]btVector3 linearLower);
//    void setLinearUpperLimit([Const, Ref]btVector3 linearUpper);
//    void setAngularLowerLimit([Const, Ref]btVector3 linearLower);
//    void setAngularUpperLimit([Const, Ref]btVector3 linearUpper);
//    void setLimit(long axis, float lo, float hi);
//    void setStiffness(long index, float stiffness);
//    void setDamping(long index, float damping);
//    void setBounce(long index, float bounce);
//    void setServo(long index, boolean onOff);
//    void setServoTarget(long index, float target);
//    void enableMotor(long index, boolean onOff);
//    void enableSpring(long index, boolean onOff);
//    void setTargetVelocity(long index, float velocity);
//    void setMaxMotorForce(long index, float force);
//    void setEquilibriumPoint();
//    void setEquilibriumPoint(long index);
//    void setEquilibriumPoint(long index, float val);
//    void setFrames([Const, Ref]btTransform frameA, [Const, Ref]btTransform frameB);
//    btRotationalLimitMotor2 getRotationalLimitMotor(long index);
//    btTranslationalLimitMotor2 getTranslationalLimitMotor();
//};
//btGeneric6DofSpring2Constraint implements btTypedConstraint;
//
//interface btRotationalLimitMotor2 {
//    attribute float m_loLimit;
//    attribute float m_hiLimit;
//    attribute float m_bounce;
//    attribute float m_stopERP;
//    attribute float m_stopCFM;
//    attribute float m_motorERP;
//    attribute float m_motorCFM;
//    attribute boolean m_enableMotor;
//    attribute float m_targetVelocity;
//    attribute float m_maxMotorForce;
//    attribute boolean m_servoMotor;
//    attribute float m_servoTarget;
//    attribute boolean m_enableSpring;
//    attribute float m_springStiffness;
//    attribute boolean m_springStiffnessLimited;
//    attribute float m_springDamping;
//    attribute boolean m_springDampingLimited;
//    attribute float m_equilibriumPoint;
//    boolean isLimited();
//    void testLimitValue(float test_value);
//};
//
//interface btTranslationalLimitMotor2 {
//    [Value]attribute btVector3 m_lowerLimit;
//    [Value]attribute btVector3 m_upperLimit;
//    [Value]attribute btVector3 m_bounce;
//    [Value]attribute btVector3 m_stopERP;
//    [Value]attribute btVector3 m_stopCFM;
//    [Value]attribute btVector3 m_motorERP;
//    [Value]attribute btVector3 m_motorCFM;
////    attribute boolean [] m_enableMotor;
////    attribute boolean [] m_servoMotor;
////    attribute boolean [] m_enableSpring;
//    [Value]attribute btVector3 m_servoTarget;
//    [Value]attribute btVector3 m_springStiffness;
////    attribute boolean [] m_springStiffnessLimited;
//    [Value]attribute btVector3 m_springDamping;
////    attribute boolean [] m_springDampingLimited;
//    [Value]attribute btVector3 m_equilibriumPoint;
//    [Value]attribute btVector3 m_targetVelocity;
//    [Value]attribute btVector3 m_maxMotorForce;
//    boolean isLimited(long limitIndex);
//    void testLimitValue(long limitIndex, float test_value);
//};
//
//interface btFixedConstraint {
//    void btFixedConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btTransform frameInA, [Const, Ref]btTransform frameInB);
//};
//btFixedConstraint implements btTypedConstraint;
//
//interface btPoint2PointConstraint {
//    void btPoint2PointConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Ref]btVector3 pivotInA, [Ref]btVector3 pivotInB);
//    void btPoint2PointConstraint([Ref]btRigidBody rbA, [Ref]btVector3 pivotInA);
//    void setPivotA([Const, Ref]btVector3 pivotA);
//    void setPivotB([Const, Ref]btVector3 pivotB);
//    [Const, Ref]btVector3 getPivotInA();
//    [Const, Ref]btVector3 getPivotInB();
//    [Value]attribute btConstraintSetting m_setting;
//};
//btPoint2PointConstraint implements btTypedConstraint;
//
//interface btGeneric6DofConstraint {
//    void btGeneric6DofConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Ref]btTransform frameInA, [Ref]btTransform frameInB, boolean useLinearFrameReferenceFrameA);
//    void btGeneric6DofConstraint([Ref]btRigidBody rbB, [Ref]btTransform frameInB, boolean useLinearFrameReferenceFrameB);
//    void setLinearLowerLimit([Const, Ref]btVector3 linearLower);
//    void setLinearUpperLimit([Const, Ref]btVector3 linearUpper);
//    void setAngularLowerLimit([Const, Ref]btVector3 angularLower);
//    void setAngularUpperLimit([Const, Ref]btVector3 angularUpper);
//};
//btGeneric6DofConstraint implements btTypedConstraint;
//
//interface btGeneric6DofSpringConstraint {
//    void btGeneric6DofSpringConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Ref]btTransform frameInA, [Ref]btTransform frameInB, boolean useLinearFrameReferenceFrameA);
//    void btGeneric6DofSpringConstraint([Ref]btRigidBody rbB, [Ref]btTransform frameInB, boolean useLinearFrameReferenceFrameB);
//    void enableSpring(long index, boolean onOff);
//    void setStiffness(long index, float stiffness);
//    void setDamping(long index, float damping);
//};
//btGeneric6DofSpringConstraint implements btGeneric6DofConstraint;

interface btSequentialImpulseConstraintSolver {
    void btSequentialImpulseConstraintSolver();
};
btSequentialImpulseConstraintSolver implements btConstraintSolver;

//interface btConeTwistConstraint {
//    void btConeTwistConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Ref]btTransform rbAFrame, [Ref]btTransform rbBFrame);
//    void btConeTwistConstraint([Ref]btRigidBody rbA, [Ref]btTransform rbAFrame);
//    void setLimit(long limitIndex, float limitValue);
//    void setLimit(float _swingSpan1, float _swingSpan2, float _twistSpan, optional float _softness, optional float _biasFactor, optional float _relaxationFactor);
//    void setAngularOnly(boolean angularOnly);
//    void setDamping(float damping);
//    void enableMotor(boolean b);
//    void setMaxMotorImpulse(float maxMotorImpulse);
//    void setMaxMotorImpulseNormalized(float maxMotorImpulse);
//    void setMotorTarget([Const, Ref]btQuaternion q);
//    void setMotorTargetInConstraintSpace([Const, Ref]btQuaternion q);
//};
//btConeTwistConstraint implements btTypedConstraint;
//
//interface btHingeConstraint {
//    void btHingeConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btVector3 pivotInA, [Const, Ref]btVector3 pivotInB, [Const, Ref]btVector3 axisInA, [Const, Ref]btVector3 axisInB, optional boolean useReferenceFrameA);
//    void btHingeConstraint([Ref]btRigidBody rbA, [Ref]btVector3 pivotInA, [Const, Ref]btVector3 axisInA, boolean useReferenceFrameA);
//    void btHingeConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btTransform rbAFrame, [Const, Ref]btTransform rbBFrame, boolean useReferenceFrameA);
//    void btHingeConstraint([Ref]btRigidBody rbA, [Const, Ref]btTransform rbAFrame, boolean useReferenceFrameA);
//    void setLimit(float low, float high, optional float softness, optional float biasFactor, optional float relaxationFactor);
//    void enableAngularMotor(boolean enableMotor, float targetVelocity, float maxMotorImpulse);
//};
//btHingeConstraint implements btTypedConstraint;
//
//interface btSliderConstraint {
//    void btSliderConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btTransform frameInA, [Const, Ref]btTransform frameInB, boolean useLinearReferenceFrameA);
//    void btSliderConstraint([Ref]btRigidBody rbB, [Const, Ref]btTransform frameInB, boolean uesLinearReferenceFrameA);
//    void setLowerLinLimit(float lowerLimit);
//    void setUpperLinLimit(float upperLimit);
//    void setLowerAngLimit(float lowerAngLimit);
//    void setUpperAngLimit(float upperAngLimit);
//};
//btSliderConstraint implements btTypedConstraint;

interface btConstraintSolver {};

//interface btDispatcherInfo {
//    attribute float m_timeStep;
//    attribute long m_stepCount;
//    attribute long m_dispatchFunc;
//    attribute float m_timeOfImpact;
//    attribute boolean m_useContinuous;
//    attribute boolean m_enableSatConvex;
//    attribute boolean m_enableSPU;
//    attribute boolean m_useEpa;
//    attribute float m_allowedCcdPenetration;
//    attribute boolean m_useConvexConservativeDistanceUtil;
//    attribute float m_convexConservativeDistanceThreshold;
//};


interface btContactSolverInfo {
    attribute boolean m_splitImpulse;
    attribute long m_splitImpulsePenetrationThreshold;
};

interface btDynamicsWorld {
    long stepSimulation(float timeStep, optional long maxSubSteps, optional float fixedTimeStep);
    void addAction(btActionInterface action);
    void removeAction(btActionInterface action);
    [Ref]btContactSolverInfo getSolverInfo();
    void addRigidBody(btRigidBody body);
    void addRigidBody(btRigidBody body, long group, long mask);
    void removeRigidBody(btRigidBody body);
    void setGravity([Ref]btVector3 gravity);
    [Value]btVector3 getGravity();
    void addConstraint(btTypedConstraint constraint, optional boolean disableCollisionsBetweenLinkedBodies);
    void removeConstraint(btTypedConstraint constraint);
    void clearForces();
};
btDynamicsWorld implements btCollisionWorld;

interface btDiscreteDynamicsWorld {
    void btDiscreteDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);
};
btDiscreteDynamicsWorld implements btDynamicsWorld;

interface btActionInterface {
    void updateAction(btCollisionWorld collisionWorld, float deltaTimeStep);
    void debugDraw(btIDebugDraw debugDrawer);
};

////Vehicle
//
//
//[Prefix = "btRaycastVehicle::"]
//interface btVehicleTuning {
//    void btVehicleTuning();
//    attribute float m_suspensionStiffness;
//    attribute float m_suspensionCompression;
//    attribute float m_suspensionDamping;
//    attribute float m_maxSuspensionTravelCm;
//    attribute float m_frictionSlip;
//    attribute float m_maxSuspensionForce;
//};
//
//interface btVehicleRaycaster {};
//
//interface btDefaultVehicleRaycaster {
//    void btDefaultVehicleRaycaster(btDynamicsWorld world);
//};
//btDefaultVehicleRaycaster implements btVehicleRaycaster;
//
//[Prefix = "btWheelInfo::"]
//interface RaycastInfo {
//    void RaycastInfo();
//    [Value]attribute btVector3 m_contactNormalWS;
//    [Value]attribute btVector3 m_contactPointWS;
//    attribute float m_suspensionLength;
//    [Value]attribute btVector3 m_hardPointWS;
//    [Value]attribute btVector3 m_wheelDirectionWS;
//    [Value]attribute btVector3 m_wheelAxleWS;
//    attribute boolean m_isInContact;
//    attribute any m_groundObject;
//};
//
////interface btWheelInfo {
////    [Value]attribute RaycastInfo m_raycastInfo;
////    [Value]attribute btTransform m_worldTransform;
////    [Value]attribute btVector3 m_chassisConnectionPointCS;
////    [Value]attribute btVector3 m_wheelDirectionCS;
////    [Value]attribute btVector3 m_wheelAxleCS;
////    attribute float m_suspensionRestLength1;
////    attribute float m_maxSuspensionTravelCm;
////    attribute float m_wheelsRadius;
////    attribute float m_suspensionStiffness;
////    attribute float m_wheelsDampingCompression;
////    attribute float m_wheelsDampingRelaxation;
////    attribute float m_frictionSlip;
////    attribute float m_steering;
////    attribute float m_rotation;
////    attribute float m_deltaRotation;
////    attribute float m_rollInfluence;
////    attribute float m_maxSuspensionForce;
////    attribute float m_engineForce;
////    attribute float m_brake;
////    attribute boolean m_bIsFrontWheel;
////    attribute float m_clippedInvContactDotSuspension;
////    attribute float m_suspensionRelativeVelocity;
////    attribute float m_wheelsSuspensionForce;
////    attribute float m_skidInfo;
////    void updateWheel([Const, Ref]btRigidBody chassis, [Ref]RaycastInfo raycastInfo);
////};
//
//interface btRaycastVehicle {
//    void btRaycastVehicle([Const, Ref]btVehicleTuning tuning, btRigidBody chassis, btVehicleRaycaster raycaster);
//    void applyEngineForce(float force, long wheel);
//    void updateVehicle(float step);
//    void resetSuspension();
//    float rayCast([Ref]btWheelInfo wheel);
//    float getSteeringValue(long wheel);
//    void setSteeringValue(float steering, long wheel);
//    [Const, Ref]btTransform getWheelTransformWS(long wheelIndex);
//    void updateWheelTransform(long wheelIndex, optional boolean interpolatedTransform);
//    void updateWheelTransformsWS([Ref]btWheelInfo wheel, optional boolean interpolatedTransform);
//    [Ref]btWheelInfo addWheel([Const, Ref]btVector3 connectionPointCS0, [Const, Ref]btVector3 wheelDirectionCS0, [Const, Ref]btVector3 wheelAxleCS, float suspensionRestLength, float wheelRadius, [Const, Ref]btVehicleTuning tuning, boolean isFrontWheel);
//    long getNumWheels();
//    btRigidBody getRigidBody();
//    [Ref]btWheelInfo getWheelInfo(long index);
//    void setBrake(float brake, long wheelIndex);
//    void setCoordinateSystem(long rightIndex, long upIndex, long forwardIndex);
//    float getCurrentSpeedKmHour();
//    long getRightAxis();
//    long getUpAxis();
//    long getForwardAxis();
//    [Value]btVector3 getForwardVector();
//    long getUserConstraintType();
//    void setUserConstraintType(long userConstraintType);
//    void setUserConstraintId(long uid);
//    long getUserConstraintId();
//    void updateFriction(float timeStep);
//    void updateSuspension(float deltaTime);
//    void setPitchControl(float pitch);
//};
//btRaycastVehicle implements btActionInterface;
//
//interface btKinematicCharacterController {
//    void btKinematicCharacterController(btPairCachingGhostObject ghostObject, btConvexShape convexShape, float stepHeight, [Ref] optional btVector3 upAxis);
//    void setUp([Const, Ref]btVector3 up);
//    void setWalkDirection([Const, Ref]btVector3 walkDirection);
//    void setVelocityForTimeInterval([Const, Ref]btVector3 velocity, float timeInterval);
//    //void reset ();
//    void warp([Const, Ref]btVector3 origin);
//    void preStep(btCollisionWorld collisionWorld);
//    void playerStep(btCollisionWorld collisionWorld, float dt);
//    void setFallSpeed(float fallSpeed);
//    void setJumpSpeed(float jumpSpeed);
//    void setMaxJumpHeight(float maxJumpHeight);
//    boolean canJump();
//    void jump([Const, Ref]optional btVector3 v);
//    void setGravity([Const, Ref]btVector3 gravity);
//    [Value]btVector3 getGravity();
//    void setMaxSlope(float slopeRadians);
//    float getMaxSlope();
//    btPairCachingGhostObject getGhostObject();
//    void setUseGhostSweepTest(boolean useGhostObjectSweepTest);
//    boolean onGround();
//};
//btKinematicCharacterController implements btActionInterface;
//
//interface btGhostObject {
//    void btGhostObject();
//    long getNumOverlappingObjects();
//    btCollisionObject getOverlappingObject(long index);
//};
//btGhostObject implements btCollisionObject;
//
//interface btPairCachingGhostObject {
//    void btPairCachingGhostObject();
//};
//btPairCachingGhostObject implements btGhostObject;
//
//interface btGhostPairCallback {
//    void btGhostPairCallback();
//};
//
////  Soft bodies
//
//// interface btSparseSdf3 {
//// void Initialize(btSoftBodyWorldInfo worldInfo, optional long hashsize, optional long clampCells);
//// void Reset(btSoftBodyWorldInfo worldInfo);
//// void GarbageCollect(btSoftBodyWorldInfo  worldInfo, optional long lifetime);
//// };
//
//interface btSoftBodyWorldInfo {
//    void btSoftBodyWorldInfo();
//    attribute float air_density;
//    attribute float water_density;
//    attribute float water_offset;
//    attribute float m_maxDisplacement;
//    [Value]attribute btVector3 water_normal;
//    attribute btBroadphaseInterface m_broadphase;
//    attribute btDispatcher m_dispatcher;
//    [Value]attribute btVector3 m_gravity;
//};
//
////[Prefix = "btSoftBody::"]
////interface tNodeArray {
////    void tNodeArray();
////    [Const]long size();
////    [Const, Ref]Node at(long n);
////    void resize(long numVertices);
////};
////
////[Prefix = "btSoftBody::"]
////interface tFaceArray {
////    void tFaceArray();
////    [Const]long size();
////    [Const, Ref]Face at(long n);
////};
////
////[Prefix = "btSoftBody::"]
////interface Node {
////    [Value]attribute btVector3 m_x;
////    [Value]attribute btVector3 m_q;
////    [Value]attribute btVector3 m_v;
////    [Value]attribute btVector3 m_f;
////    [Value]attribute btVector3 m_n;
////    attribute float m_im;
////    attribute float m_area;
////};
//
////[Prefix = "btSoftBody::"]
////interface Face {
////    // [Value] attribute Node  m_n;
////    [Value]attribute btVector3 m_normal;
////    attribute float m_ra;
////};
//
////[Prefix = "btSoftBody::"]
////interface Element {
////    attribute any m_tag;
////};
//
////[Prefix = "btSoftBody::"]
////interface Material {
////    attribute float m_kLST;
////    attribute float m_kAST;
////    attribute float m_kVST;
////    attribute long m_flags;
////};
////Material implements Element;
//
////[Prefix = "btSoftBody::"]
////interface tMaterialArray {
////    void tMaterialArray();
////    [Const]long size();
////    Material at(long n);
////};
//
////[Prefix = "btSoftBody::"]
////interface Config {
////    void Config();
////    attribute float kVCF;
////    attribute float kDP;
////    attribute float kDG;
////    attribute float kLF;
////    attribute float kPR;
////    attribute float kVC;
////    attribute float kDF;
////    attribute float kMT;
////    attribute float kCHR;
////    attribute float kKHR;
////    attribute float kSHR;
////    attribute float kAHR;
////    attribute float kSRHR_CL;
////    attribute float kSKHR_CL;
////    attribute float kSSHR_CL;
////    attribute float kSR_SPLT_CL;
////    attribute float kSK_SPLT_CL;
////    attribute float kSS_SPLT_CL;
////    attribute float maxvolume;
////    attribute float timescale;
////    attribute long viterations;
////    attribute long piterations;
////    attribute long diterations;
////    attribute long citerations;
////    attribute long collisions;
////};
//
//interface btSoftBody {
//    void btSoftBody(btSoftBodyWorldInfo worldInfo); //, long node_count, [Const] btVector3 x, [Const] long m);
//
////    [Value]attribute Config m_cfg;
////    [Value]attribute tNodeArray m_nodes;
////    [Value]attribute tFaceArray m_faces;
////    [Value]attribute tMaterialArray m_materials;
//
//    [Const]boolean checkLink(long node0, long node1);
//    [Const]boolean checkFace(long node0, long node1, long node2);
////    Material appendMaterial();
//    void appendNode([Const, Ref]btVector3 x, float m);
////    void appendLink(long node0, long node1, Material mat, boolean bcheckexist);
////    void appendFace(long node0, long node1, long node2, Material mat);
////    void appendTetra(long node0, long node1, long node2, long node3, Material mat);
//    void appendAnchor(long node, btRigidBody body, boolean disableCollisionBetweenLinkedBodies, float influence);
//    [Const]float getTotalMass();
//    void setTotalMass(float mass, optional boolean fromfaces);
//    void setMass(long node, float mass);
//    void transform([Const, Ref]btTransform trs);
//    void translate([Const, Ref]btVector3 trs);
//    void rotate([Const, Ref]btQuaternion rot);
//    void scale([Const, Ref]btVector3 scl);
//    long generateClusters(long k, optional long maxiterations);
//    void randomizeConstraints();
////    long generateBendingConstraints(long distance, optional Material mat);
//    btSoftBody upcast(btCollisionObject colObj);
//};
//btSoftBody implements btCollisionObject;
//
//interface btSoftBodyRigidBodyCollisionConfiguration {
//    void btSoftBodyRigidBodyCollisionConfiguration([Ref]optional btDefaultCollisionConstructionInfo info);
//};
//btSoftBodyRigidBodyCollisionConfiguration implements btDefaultCollisionConfiguration;
//
//interface btSoftBodySolver {};
//
//interface btDefaultSoftBodySolver {
//    void btDefaultSoftBodySolver();
//};
//btDefaultSoftBodySolver implements btSoftBodySolver;
//
//interface btSoftBodyArray {
//    [Const]long size();
//    [Const]btSoftBody at(long n);
//};
//
//interface btSoftRigidDynamicsWorld {
//    void btSoftRigidDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration, optional btSoftBodySolver softBodySolver);
//    void addSoftBody(btSoftBody body, optional long collisionFilterGroup, optional long collisionFilterMask);
//    void removeSoftBody(btSoftBody body);
//    [Ref]btSoftBodyWorldInfo getWorldInfo();
//    [Ref]btSoftBodyArray getSoftBodyArray();
//    long getDrawFlags();
//    void setDrawFlags(long f);
//};
//btSoftRigidDynamicsWorld implements btDiscreteDynamicsWorld;

// interface btMultiBody {

// };

// interface btMultiBodyLinkCollider {
// void btMultiBodyLinkCollider(btMultiBody multiBody, long link);

// };
// btMultiBodyLinkCollider implements btCollisionObject;

// interface btMultiBodyConstraintSolver {

// };
// btMultiBodyConstraintSolver implements btSequentialImpulseConstraintSolver;

// interface btMultiBodyDynamicsWorld {
// void btMultiBodyDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btMultiBodyConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);


// };
// btMultiBodyDynamicsWorld implements btDiscreteDynamicsWorld;
//
//interface btSoftBodyHelpers {
//    void btSoftBodyHelpers();
//    btSoftBody CreateRope([Ref]btSoftBodyWorldInfo worldInfo, [Const, Ref]btVector3 from, [Const, Ref]btVector3 to, long res, long fixeds);
//    btSoftBody CreatePatch([Ref]btSoftBodyWorldInfo worldInfo, [Const, Ref]btVector3 corner00, [Const, Ref]btVector3 corner10, [Const, Ref]btVector3 corner01, [Const, Ref]btVector3 corner11, long resx, long resy, long fixeds, boolean gendiags);
//    // btSoftBody CreatePatchUV([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 corner00, [Const, Ref] btVector3 corner10, [Const, Ref] btVector3 corner01, [Const, Ref] btVector3 corner11, long resx, long resy, long fixeds, boolean gendiags, float[] tex_coords);
//    btSoftBody CreateEllipsoid([Ref]btSoftBodyWorldInfo worldInfo, [Const, Ref]btVector3 center, [Const, Ref]btVector3 radius, long res);
//    // btSoftBody CreateFromTriMesh([Ref] btSoftBodyWorldInfo worldInfo, float[] vertices, long[] triangles, long ntriangles, boolean randomizeConstraints);
//    btSoftBody CreateFromConvexHull([Ref]btSoftBodyWorldInfo worldInfo, [Const]btVector3 vertices, long nvertices, boolean randomizeConstraints);
//};



